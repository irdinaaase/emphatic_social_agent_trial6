<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Controls & Eye Tracker</title>
    <style>
        /* CAMERA COLLAPSIBLE WITH BUBBLES */
        :root {
            --mickey-red: #d84a54;
            --mickey-yellow: #e9a946;
            --mickey-black: #25221a;
            --mickey-white: #e9e7db;
            --mickey-blue: #8ac6d1;
            --mickey-pink: #ffb8c6;
            --mickey-green: #95e1d3;
            --mickey-purple: #b8b8ff;
            --mickey-bg: #fff5f5;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Fredoka One', cursive;
            min-height: 100vh;
            position: relative;
        }

        /* SIDE COLLAPSIBLE BUBBLES */
        .side-collapsible {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 9997;
        }

        .side-toggle {
            width: 60px;
            height: 60px;
            background: var(--mickey-red);
            border-radius: 50%;
            border: 4px solid var(--mickey-black);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(255, 107, 139, 0.4);
            transition: all 0.3s;
            animation: pulse 2s infinite;
        }

        .side-toggle:hover {
            transform: scale(1.1);
        }

        .side-toggle i {
            color: var(--mickey-white);
            font-size: 1.5rem;
        }

        /* Enhanced Side Bubbles System */
        .side-bubbles {
            position: absolute;
            bottom: 70px;
            right: 0;
            display: none;
            flex-direction: column;
            gap: 15px;
            animation: slideUp 0.3s ease;
            z-index: 9998;
        }

        .side-bubbles.show {
            display: flex;
        }

        .side-bubble {
            width: 60px;
            height: 60px;
            background: var(--mickey-yellow);
            border-radius: 50%;
            border: 4px solid var(--mickey-black);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: all 0.3s;
            position: relative;
        }

        .side-bubble:hover {
            transform: scale(1.1) rotate(10deg);
            background: var(--mickey-white);
        }

        .side-bubble i {
            color: var(--mickey-red);
            font-size: 1.5rem;
        }

        /* Bubble variants */
        .side-bubble.emotion-camera {
            background: var(--mickey-pink);
        }

        .side-bubble.emotion-camera i {
            color: var(--mickey-white);
        }

        .side-bubble.eye-camera {
            background: var(--mickey-blue);
        }

        .side-bubble.eye-camera i {
            color: var(--mickey-white);
        }

        .side-bubble.speaking-bot {
            background: var(--mickey-pink);
            animation: pulse 2s infinite;
        }

        .side-bubble.speaking-bot i {
            color: var(--mickey-white);
        }

        .side-bubble.active {
            background: var(--mickey-green);
            transform: scale(1.1);
            box-shadow: 0 0 20px var(--mickey-green);
            animation: pulse 2s infinite;
        }

        .side-bubble.active i {
            color: var(--mickey-white);
        }

        /* Camera status indicators */
        .camera-status-dot {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 2px solid var(--mickey-white);
            display: none;
        }

        .camera-status-dot.active {
            background: var(--mickey-green);
            box-shadow: 0 0 10px var(--mickey-green);
            display: block;
            animation: pulse-green 2s infinite;
        }

        .camera-status-dot.inactive {
            background: var(--mickey-red);
            display: block;
        }

        /* CAMERA COLLAPSIBLE CONTENT */
        .collapsible-controls {
            position: fixed;
            top: 120px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 9999;
        }

        .collapsible-content {
            display: none;
            position: absolute;
            top: -30px;
            right: 0;
            background: var(--mickey-white);
            border-radius: 20px;
            border: 4px solid var(--mickey-black);
            padding: 20px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            z-index: 9997;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .camera-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .collapsible-content::-webkit-scrollbar {
            width: 8px;
        }

        .collapsible-content::-webkit-scrollbar-track {
            background: var(--mickey-yellow);
            border-radius: 10px;
        }

        .collapsible-content::-webkit-scrollbar-thumb {
            background: var(--mickey-red);
            border-radius: 10px;
            border: 2px solid var(--mickey-white);
        }

        .collapsible-content::-webkit-scrollbar-thumb:hover {
            background: var(--mickey-pink);
        }

        .collapsible-content.active {
            display: block;
            animation: slideInRight 0.3s ease;
        }

        .collapsible-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: var(--mickey-red);
            color: var(--mickey-white);
            border: 3px solid var(--mickey-black);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            z-index: 9998;
            transition: all 0.3s;
        }

        .collapsible-close-btn:hover {
            background: var(--mickey-blue);
            transform: rotate(90deg) scale(1.1);
        }

        /* Enhanced detection interface */
        .dual-screen-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin: 20px 0;
        }

        .detection-screen {
            background: var(--mickey-white);
            border-radius: 15px;
            border: 4px solid var(--mickey-black);
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .screen-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .screen-title {
            color: var(--mickey-red);
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .screen-status {
            background: var(--mickey-yellow);
            padding: 5px 10px;
            border-radius: 15px;
            border: 2px solid var(--mickey-black);
            font-size: 0.8rem;
            color: var(--mickey-black);
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .screen-status.active {
            background: var(--mickey-green);
            color: white;
        }

        .video-container {
            position: relative;
            width: 100%;
            height: 180px;
            background: black;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .detection-video {
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            object-fit: cover;
        }

        .detection-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .detection-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .stat-item {
            background: var(--mickey-yellow);
            padding: 8px;
            border-radius: 8px;
            border: 2px solid var(--mickey-black);
            text-align: center;
        }

        .stat-value {
            font-size: 1rem;
            font-weight: bold;
            color: var(--mickey-red);
            line-height: 1.2;
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--mickey-black);
        }

        /* Focus and emotion indicators */
        .focus-status {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 15px;
            color: white;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 10;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        .status-focusing {
            background: #4CAF50;
            box-shadow: 0 0 5px #4CAF50;
        }

        .status-distracted {
            background: #f44336;
            box-shadow: 0 0 5px #f44336;
        }

        .status-unknown {
            background: #FFA500;
            box-shadow: 0 0 5px #FFA500;
        }

        .iris-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 4px 6px;
            border-radius: 6px;
            color: white;
            font-size: 9px;
            z-index: 10;
            line-height: 1.2;
        }

        .emotion-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 4px 6px;
            border-radius: 6px;
            color: white;
            font-size: 9px;
            z-index: 10;
            line-height: 1.2;
        }

        /* Detection status panel */
        .detection-status-panel {
            margin-top: 15px;
            padding: 15px;
            background: var(--mickey-yellow);
            border-radius: 10px;
            border: 3px solid var(--mickey-black);
        }

        .status-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .status-icon {
            font-size: 1.5rem;
            color: var(--mickey-red);
        }

        .status-title {
            color: var(--mickey-black);
            font-weight: bold;
            font-size: 1rem;
        }

        .status-message {
            color: var(--mickey-black);
            font-size: 0.9rem;
            line-height: 1.4;
        }

        /* SPEAKING BOT OVERLAY STYLES */
        #speaking-bot-overlay-main {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }

        #speaking-bot-overlay-main.show {
            display: flex;
        }

        #speaking-bot-container-main {
            width: 90%;
            max-width: 500px;
            height: 80vh;
            background: #1a1a2e;
            border-radius: 20px;
            border: 4px solid #e9a946;
            position: relative;
            overflow: hidden;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            animation: scaleUp 0.3s ease;
        }

        #close-speaking-bot {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            background: #d84a54;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            z-index: 10001;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        #close-speaking-bot:hover {
            background: #ff6b8b;
            transform: scale(1.1);
        }

        #speaking-bot-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Speaking indicator */
        .speaking-indicator {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 10001;
            font-family: 'Comic Neue', cursive;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .speaking-indicator i {
            color: #4CAF50;
            animation: pulse 1s infinite;
        }

        /* ANIMATIONS */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes slideUp {
            0% { 
                transform: translateY(20px); 
                opacity: 0; 
            }
            100% { 
                transform: translateY(0); 
                opacity: 1; 
            }
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(149, 225, 211, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(149, 225, 211, 0); }
            100% { box-shadow: 0 0 0 0 rgba(149, 225, 211, 0); }
        }

        @keyframes scaleUp {
            from {
                transform: scale(0.9);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes slideOutRight {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(20px);
            }
        }

        /* RESPONSIVE */
        @media (max-width: 768px) {
            .side-collapsible {
                bottom: 20px;
                right: 20px;
            }
            
            .collapsible-controls {
                top: 100px;
                right: 20px;
            }
            
            .collapsible-content {
                width: 280px;
            }
            
            .dual-screen-container {
                gap: 15px;
            }
            
            .video-container {
                height: 150px;
            }
            
            #speaking-bot-container-main {
                width: 95%;
                height: 85vh;
            }
        }
    </style>
</head>
<body>
    <!-- SIDE BUBBLES -->
    <div class="side-collapsible" id="side-collapsible">
        <div class="side-toggle" id="side-toggle">
            <i class="fas fa-plus"></i>
        </div>
        <div class="side-bubbles" id="side-bubbles">
            <!-- Emotion Camera Bubble -->
            <div class="side-bubble emotion-camera" id="side-emotion-camera" title="Emotion Detection">
                <i class="fas fa-smile"></i>
                <div class="camera-status-dot" id="emotion-status-dot"></div>
            </div>
            
            <!-- Eye Tracking Camera Bubble -->
            <div class="side-bubble eye-camera" id="side-eye-camera" title="Eye Tracking">
                <i class="fas fa-eye"></i>
                <div class="camera-status-dot" id="eye-status-dot"></div>
            </div>
            
            <!-- Speaking Bot Bubble -->
            <div class="side-bubble speaking-bot" id="side-speaking-bot" title="Click to talk">
                <i class="fas fa-microphone"></i>
            </div>
        </div>
    </div>

    <!-- CAMERA COLLAPSIBLE CONTENT -->
    <div class="collapsible-controls" id="collapsible-controls">
        <div class="collapsible-content" id="camera-content">
            <button class="collapsible-close-btn" id="close-camera-content" title="Close camera panel">
                <i class="fas fa-times"></i>
            </button>
            <div class="camera-container">
                <!-- Dual Detection Screens -->
                <div class="dual-screen-container">
                    <!-- Emotion Detection Screen -->
                    <div class="detection-screen" id="emotion-screen">
                        <div class="screen-header">
                            <div class="screen-title">
                                <i class="fas fa-smile"></i> Emotion Detection
                            </div>
                            <div class="screen-status" id="emotion-status">
                                <i class="fas fa-circle"></i> AUTO-ONLY (In Game)
                            </div>
                        </div>
                        
                        <div class="video-container">
                            <video id="emotion-video" class="detection-video" playsinline muted></video>
                            <canvas id="emotion-overlay" class="detection-overlay"></canvas>
                            <div class="emotion-info" id="emotion-info">
                                Status: Waiting for game to start
                            </div>
                        </div>
                        
                        <div class="detection-stats">
                            <div class="stat-item">
                                <div class="stat-value" id="face-count">-</div>
                                <div class="stat-label">Faces</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="dominant-emotion">-</div>
                                <div class="stat-label">Emotion</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="emotion-confidence">-</div>
                                <div class="stat-label">Confidence</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="emotion-fps">-</div>
                                <div class="stat-label">FPS</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Eye Tracking Screen -->
                    <div class="detection-screen" id="eye-screen">
                        <div class="screen-header">
                            <div class="screen-title">
                                <i class="fas fa-eye"></i> Eye Tracking
                            </div>
                            <div class="screen-status" id="eye-status">
                                <i class="fas fa-circle"></i> AUTO-ONLY (In Game)
                            </div>
                        </div>
                        
                        <div class="video-container">
                            <video id="eye-video" class="detection-video" playsinline muted></video>
                            <canvas id="eye-tracking-canvas" class="detection-overlay"></canvas>
                            
                            <div class="focus-status" id="focus-status">
                                <div class="status-dot status-unknown"></div>
                                <span>Eye: Waiting for game</span>
                            </div>
                            <div class="iris-info" id="iris-info">
                                Status: Waiting for game to start
                            </div>
                        </div>
                        
                        <div class="detection-stats">
                            <div class="stat-item">
                                <div class="stat-value" id="eye-iris-confidence">-</div>
                                <div class="stat-label">Iris Conf</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="focus-direction">-</div>
                                <div class="stat-label">Direction</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="eye-score">-</div>
                                <div class="stat-label">Eye Score</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="eye-alignment-score">-</div>
                                <div class="stat-label">Alignment</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- INFO MESSAGE -->
                <div class="detection-status-panel" id="detection-status" style="margin-top: 20px;">
                    <div class="status-header">
                        <div class="status-icon">
                            <i class="fas fa-gamepad"></i>
                        </div>
                        <div class="status-title">
                            AUTO-ACTIVATION SYSTEM
                        </div>
                    </div>
                    <div class="status-message">
                        <br><br>
                        <i class="fas fa-info-circle"></i> Start any game to begin monitoring.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- SPEAKING BOT OVERLAY -->
    <div id="speaking-bot-overlay-main">
        <div id="speaking-bot-container-main">
            <button id="close-speaking-bot">√ó</button>
            <iframe id="speaking-bot-iframe" src="speaking-bot.html"></iframe>
        </div>
    </div>

    <!-- SPEAKING INDICATOR -->
    <div class="speaking-indicator" id="speaking-indicator" style="display: none;">
        <i class="fas fa-volume-up"></i>
        <span id="speaking-text">Speaking...</span>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@vladmandic/human/dist/human.js"></script>
    
    <script>
        // ============================================
        // SPEECH SYNTHESIS SYSTEM
        // ============================================

        class SpeechSynthesisManager {
            constructor() {
                this.isSpeaking = false;
                this.currentUtterance = null;
                this.queue = [];
                this.speakingIndicator = document.getElementById('speaking-indicator');
                this.speakingText = document.getElementById('speaking-text');
                
                // Check if speech synthesis is available
                this.speechAvailable = 'speechSynthesis' in window;
                
                if (!this.speechAvailable) {
                    console.warn('Speech synthesis not available in this browser');
                }
            }
            
            // Speak text immediately
            speak(text, onComplete = null) {
                if (!this.speechAvailable || this.isSpeaking) {
                    if (onComplete) onComplete();
                    return;
                }
                
                this.isSpeaking = true;
                
                // Show speaking indicator
                this.showSpeakingIndicator(text);
                
                // Create utterance
                this.currentUtterance = new SpeechSynthesisUtterance(text);
                this.currentUtterance.rate = 0.9;
                this.currentUtterance.pitch = 1.2;
                this.currentUtterance.volume = 1;
                
                // Try to get a friendly voice
                const voices = speechSynthesis.getVoices();
                const friendlyVoice = voices.find(voice => 
                    voice.name.includes('Child') || 
                    voice.name.includes('Kids') ||
                    voice.lang.includes('en')
                );
                
                if (friendlyVoice) {
                    this.currentUtterance.voice = friendlyVoice;
                }
                
                // Set up event handlers
                this.currentUtterance.onstart = () => {
                    console.log('üé§ Speaking:', text);
                };
                
                this.currentUtterance.onend = () => {
                    console.log('‚úÖ Finished speaking');
                    this.isSpeaking = false;
                    this.currentUtterance = null;
                    this.hideSpeakingIndicator();
                    
                    if (onComplete) {
                        setTimeout(onComplete, 500);
                    }
                    
                    // Process next in queue
                    this.processQueue();
                };
                
                this.currentUtterance.onerror = (event) => {
                    if (event.error === 'interrupted' || event.error === 'canceled') {
                        console.log('üîÑ Speech was interrupted/canceled (normal behavior)');
                    } else {
                        console.error('‚ùå Speech synthesis error:', event);
                    }
                    
                    this.isSpeaking = false;
                    this.currentUtterance = null;
                    this.hideSpeakingIndicator();
                    
                    if (onComplete) {
                        setTimeout(onComplete, 500);
                    }
                    
                    this.processQueue();
                };
                
                // Start speaking
                speechSynthesis.speak(this.currentUtterance);
            }
            
            // Queue text to speak
            queueSpeak(text, onComplete = null) {
                this.queue.push({ text, onComplete });
                
                if (!this.isSpeaking) {
                    this.processQueue();
                }
            }
            
            // Process the speech queue
            processQueue() {
                if (this.queue.length === 0 || this.isSpeaking) {
                    return;
                }
                
                const nextItem = this.queue.shift();
                this.speak(nextItem.text, nextItem.onComplete);
            }
            
            // Show speaking indicator
            showSpeakingIndicator(text) {
                if (this.speakingIndicator && this.speakingText) {
                    const displayText = text.length > 50 ? text.substring(0, 47) + '...' : text;
                    this.speakingText.textContent = displayText;
                    this.speakingIndicator.style.display = 'flex';
                }
            }
            
            // Hide speaking indicator
            hideSpeakingIndicator() {
                if (this.speakingIndicator) {
                    this.speakingIndicator.style.display = 'none';
                }
            }
            
            // Stop speaking
            stop() {
                if (this.isSpeaking && this.currentUtterance) {
                    speechSynthesis.cancel();
                    this.isSpeaking = false;
                    this.currentUtterance = null;
                    this.hideSpeakingIndicator();
                }
                
                // Clear queue
                this.queue = [];
            }
            
            // Check if currently speaking
            isCurrentlySpeaking() {
                return this.isSpeaking;
            }
        }

        // ============================================
        // SIDE TOGGLE SYSTEM
        // ============================================

        function initSideToggle() {
            const sideToggle = document.getElementById('side-toggle');
            const sideBubbles = document.getElementById('side-bubbles');
            
            if (!sideToggle || !sideBubbles) {
                console.warn("Side toggle elements not found, skipping initialization");
                return;
            }
            
            let sideOpen = false;
            
            sideToggle.addEventListener('click', function(event) {
                event.stopPropagation();
                sideOpen = !sideOpen;
                
                if (sideOpen) {
                    sideBubbles.classList.add('show');
                    sideToggle.innerHTML = '<i class="fas fa-times"></i>';
                    sideToggle.style.background = '#8ac6d1';
                } else {
                    sideBubbles.classList.remove('show');
                    sideToggle.innerHTML = '<i class="fas fa-plus"></i>';
                    sideToggle.style.background = '#d84a54';
                }
            });
            
            // Initialize bubble handlers
            initBubbleHandlers();
            
            document.addEventListener('click', function(event) {
                if (!event.target.closest('#side-collapsible') && sideOpen) {
                    sideBubbles.classList.remove('show');
                    sideOpen = false;
                    sideToggle.innerHTML = '<i class="fas fa-plus"></i>';
                    sideToggle.style.background = '#d84a54';
                }
            });
        }

        function initBubbleHandlers() {
            // Emotion camera bubble
            const emotionBubble = document.getElementById('side-emotion-camera');
            if (emotionBubble) {
                emotionBubble.addEventListener('click', function(event) {
                    event.stopPropagation();
                    
                    openCameraPanel();
                    
                    if (window.dualCameraDetection && !window.dualCameraDetection.isEmotionRunning) {
                        showNotification(
                            "Auto-Activation",
                            "Emotion detection activates automatically when you start a game! üéÆ",
                            "info"
                        );
                    }
                    
                    closeSideBubbles();
                });
                
                emotionBubble.style.cursor = 'pointer';
                emotionBubble.title = 'View Emotion Detection Status (Auto-activated with games)';
            }
            
            // Eye camera bubble
            const eyeBubble = document.getElementById('side-eye-camera');
            if (eyeBubble) {
                eyeBubble.addEventListener('click', function(event) {
                    event.stopPropagation();
                    
                    openCameraPanel();
                    
                    if (window.dualCameraDetection && !window.dualCameraDetection.isEyeTracking) {
                        showNotification(
                            "Auto-Activation",
                            "Eye tracking activates automatically when you start a game! üëÅÔ∏è",
                            "info"
                        );
                    }
                    
                    closeSideBubbles();
                });
                
                eyeBubble.style.cursor = 'pointer';
                eyeBubble.title = 'View Eye Tracking Status (Auto-activated with games)';
            }
            
            // Speaking bot bubble
            const speakingBotBubble = document.getElementById('side-speaking-bot');
            if (speakingBotBubble) {
                speakingBotBubble.addEventListener('click', function(event) {
                    event.stopPropagation();
                    
                    showSpeakingBotOverlay();
                    
                    closeSideBubbles();
                });
            }
            
            // Close camera content button
            const closeCameraBtn = document.getElementById('close-camera-content');
            if (closeCameraBtn) {
                closeCameraBtn.addEventListener('click', function(event) {
                    event.stopPropagation();
                    closeCameraPanel();
                });
            }
            
            // Close speaking bot button
            const closeSpeakingBotBtn = document.getElementById('close-speaking-bot');
            if (closeSpeakingBotBtn) {
                closeSpeakingBotBtn.addEventListener('click', function(event) {
                    event.stopPropagation();
                    hideSpeakingBotOverlay();
                });
            }
        }

        // SPEAKING BOT OVERLAY FUNCTIONS
        function showSpeakingBotOverlay() {
            const overlay = document.getElementById('speaking-bot-overlay-main');
            if (overlay) {
                overlay.classList.add('show');
                
                const iframe = document.getElementById('speaking-bot-iframe');
                if (iframe) {
                    iframe.src = iframe.src;
                }
            }
        }

        function hideSpeakingBotOverlay() {
            const overlay = document.getElementById('speaking-bot-overlay-main');
            if (overlay) {
                overlay.classList.remove('show');
            }
        }

        function openCameraPanel() {
            document.querySelectorAll('.collapsible-content').forEach(content => {
                content.classList.remove('active');
            });
            
            const cameraContent = document.getElementById('camera-content');
            if (cameraContent) {
                cameraContent.classList.add('active');
            }
        }

        function closeCameraPanel() {
            const cameraContent = document.getElementById('camera-content');
            if (cameraContent) {
                cameraContent.classList.remove('active');
            }
        }

        function closeSideBubbles() {
            const sideBubbles = document.getElementById('side-bubbles');
            if (sideBubbles) {
                sideBubbles.classList.remove('show');
            }
            
            const sideToggle = document.getElementById('side-toggle');
            if (sideToggle) {
                sideToggle.innerHTML = '<i class="fas fa-plus"></i>';
                sideToggle.style.background = '#d84a54';
            }
        }

        function showNotification(title, message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 100px;
                right: 30px;
                background: #e9e7db;
                color: #25221a;
                padding: 15px 20px;
                border-radius: 15px;
                border: 3px solid #25221a;
                box-shadow: 0 5px 15px rgba(0,0,0,0.2);
                z-index: 10000;
                font-family: 'Comic Neue', cursive;
                max-width: 300px;
                animation: slideInRight 0.3s ease;
            `;
            
            notification.innerHTML = `
                <strong style="color: #d84a54; display: block; margin-bottom: 5px;">${title}</strong>
                <div>${message}</div>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 5000);
        }

        // ============================================
        // FULL SCREEN INTERVENTION SYSTEM
        // ============================================

        class FullScreenIntervention {
            constructor() {
                this.isActive = false;
                this.currentIntervention = null;
                this.blockGameEvents = true;
                
                this.speechManager = new SpeechSynthesisManager();
                
                this.interventionOptions = {
                    anger: {
                        title: "Feeling Frustrated?",
                        message: "I notice you're feeling frustrated. Let's take a moment to calm down before continuing!",
                        options: [
                            { text: "Take breath", icon: "fa-wind", action: "breathe", color: "#95e1d3", response: "Great! Let's take three deep breaths together. In... and out... In... and out..." },
                            { text: "Take break", icon: "fa-coffee", action: "break", color: "#8ac6d1", response: "Perfect! Let's take a 30-second break. Stretch and relax!" },
                            { text: "Do stretching", icon: "fa-running", action: "stretch", color: "#ffb8c6", response: "Excellent choice! Let's stretch our arms and shake out the frustration!", video:"https://www.youtube.com/embed/WZJAIkmT3Rg?si=ojtJwdTdz5TnJrSh"},
                            { text: "Tell joke", icon: "fa-grin-squint", action: "joke", color: "#e9a946", response: "Why did the math book look sad? Because it had too many problems! üòÑ Ready to continue?" }
                        ]
                    },
                    disgust: {
                        title: "Not Enjoying This?",
                        message: "I see you're not enjoying this activity. Let's try something different!",
                        options: [
                            { text: "Try a different game", icon: "fa-random", action: "different", color: "#95e1d3", response: "Good idea! Let's switch to something you might enjoy more!" },
                            { text: "Take break", icon: "fa-coffee", action: "break", color: "#8ac6d1", response: "Let's take a quick break and come back refreshed!" },
                            { text: "Explain differently", icon: "fa-comment-alt", action: "explain", color: "#ffb8c6", response: "Let me explain this in a simpler way..." },
                            { text: "Make easier", icon: "fa-thumbs-up", action: "easier", color: "#e9a946", response: "I'll make this easier for you! Let's start with the basics." }
                        ]
                    },
                    fear: {
                        title: "Feeling Nervous?",
                        message: "It's okay to feel a bit nervous! Let's take this slowly and build confidence!",
                        options: [
                            { text: "Take it step by step", icon: "fa-tachometer-alt-slow", action: "slow", color: "#95e1d3", response: "Perfect! Let's break it down into smaller steps. No rush at all!" },
                            { text: "Start basics", icon: "fa-undo", action: "basics", color: "#8ac6d1", response: "Great idea! Let's go back to what you already know and build from there!" },
                            { text: "Take break", icon: "fa-spa", action: "calm", color: "#ffb8c6", response: "Let's calm down and relax together!", video:"https://www.youtube.com/embed/O1hKRtDclXI?si=Td9zpGyHCXzFAIUK"},
                            { text: "Get encouragement", icon: "fa-heart", action: "encourage", color: "#e9a946", response: "You're doing much better than you think! I believe in you! Let's keep going!" }
                        ]
                    },
                    sad: {
                        title: "Feeling Down?",
                        message: "I notice you're feeling a bit sad. Let's cheer you up!",
                        options: [
                            { text: "Listen song", icon: "fa-music", action: "music", color: "#95e1d3", response: "Let's watch a cheerful singing video to lift your mood! üéµ", video: "https://www.youtube.com/embed/yebNIHKAC4A" },
                            { text: "Take break", icon: "fa-gamepad", action: "funbreak", color: "#8ac6d1", response: "Let's take a fun break! And play short game", video: "https://www.youtube.com/embed/DxSl5hHP-zA?si=CcL0rLvyqu2Rbaem" },
                            { text: "Hear story", icon: "fa-book", action: "story", color: "#ffb8c6", response: "Let's watch a short story video together!",  video:"https://www.youtube.com/embed/iDhlqk0cx9s?si=qpTjX1pvWX_snb1E" },
                            { text: "Get hug", icon: "fa-hands", action: "hug", color: "#e9a946", response: "Sending you a big virtual hug! ü§ó You're doing amazing!" }
                        ]
                    },
                    distracted: {
                        title: "Need to Refocus?",
                        message: "I notice your attention drifting. Let's get you back on track!",
                        options: [
                            { text: "Do stretch", icon: "fa-running", action: "stretch", color: "#95e1d3", response: "Let's stand up and dance", video:"https://www.youtube.com/embed/WZJAIkmT3Rg?si=ojtJwdTdz5TnJrSh"},
                            { text: "Take break", icon: "fa-hourglass-half", action: "break", color: "#8ac6d1", response: "Perfect! Let's take a quick 1-minute break to reset your focus!" },
                            { text: "Refocus", icon: "fa-eye", action: "refocus", color: "#ffb8c6", response: "Excellent! Blink three times, then focus on one thing in the room. Ready?" },
                            { text: "Take breaths", icon: "fa-wind", action: "breathe", color: "#e9a946", response: "Let's calm down and relax together!", video:"https://www.youtube.com/embed/O1hKRtDclXI?si=Td9zpGyHCXzFAIUK" }
                        ]
                    }
                };
            }
            
show(emotion) {
    if (this.isActive) return;
    
    console.log(`üö® Showing FULL SCREEN intervention for: ${emotion}`);
    this.isActive = true;
    this.currentIntervention = emotion;
    
    const interventionData = this.interventionOptions[emotion] || this.interventionOptions.anger;
    
    if (window.parent !== window) {
        window.parent.postMessage({
            type: 'SHOW_FULLSCREEN_INTERVENTION',
            emotion: emotion,
            title: interventionData.title,
            message: interventionData.message,  // Send message to parent
            options: interventionData.options,
            timestamp: Date.now()
        }, '*');
    }
    
    this.blockGameInput();
    this.startTimer();
    
    // DO NOT SPEAK HERE - Let parent handle it
    // this.speechManager.speak(interventionData.message, () => {
    //     console.log('‚úÖ Finished speaking intervention message');
    // });
    
    console.log('üì§ Sent intervention to parent for speaking');
}

hide() {
    if (!this.isActive) return;
    
    console.log("‚úÖ Hiding full screen intervention");
    this.isActive = false;
        
    // Clear the auto-hide timer
    if (this.autoHideTimer) {
        clearTimeout(this.autoHideTimer);
        this.autoHideTimer = null;
    }
    
    this.speechManager.stop();
    this.stopTimer();
    this.unblockGameInput();
    
    // Notify parent window that intervention is COMPLETELY done
    if (window.parent !== window) {
        window.parent.postMessage({
            type: 'INTERVENTION_FULLY_COMPLETED',  // Changed type
            emotion: this.currentIntervention,
            timestamp: Date.now()
        }, '*');
    }
    
    // Clear the current intervention
    this.currentIntervention = null;
    
    // Also notify local InterventionMonitor that intervention is over
    if (window.interventionMonitor) {
        window.interventionMonitor.enableMonitoring();
        console.log('‚úÖ Notified InterventionMonitor that intervention ended');
    }
}

            speakInterventionMessage(message, onComplete = null) {
                this.speechManager.speak(message, onComplete);
            }
            
            speakOptionResponse(response, onComplete = null) {
                this.speechManager.speak(response, onComplete);
            }
            
            startTimer() {
                this.timerInterval = setInterval(() => {
                    // Internal timer logic
                }, 1000);
            }
            
            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }
            
            blockGameInput() {
                this.blockGameEvents = true;
            }
            
            unblockGameInput() {
                this.blockGameEvents = false;
            }
            
            isInterventionActive() {
                return this.isActive;
            }
            
            isCurrentlySpeaking() {
                return this.speechManager.isCurrentlySpeaking();
            }
            
            handleOptionResponse(optionResponse, onComplete = null) {
                this.speakOptionResponse(optionResponse, () => {
                    console.log('‚úÖ Finished speaking option response');
                    
                    setTimeout(() => {
                        this.hide();
                    }, 1000);
                });
            }
        }

        // ============================================
        // INTERVENTION MONITORING SYSTEM
        // ============================================

        class InterventionMonitor {
            constructor() {
                this.state = {
                    emotionHistory: [],
                    lastEmotionDetection: 0,
                    sameEmotionCount: 0,
                    currentDetectedEmotion: 'neutral',
                    emotionFrameColor: '#ffffff',
                    EMOTION_TRIGGER_COUNT: 3,
                    COOLDOWN: 1000,
                    monitoringEnabled: true  // Added flag to control monitoring
                };
                
                this.emotionColors = {
                    'anger': '#d84a54',
                    'disgust': '#95e1d3',
                    'fear': '#b8b8ff',
                    'happy': '#e9a946',
                    'sad': '#8ac6d1',
                    'surprise': '#ffb8c6',
                    'contempt': '#cccccc',
                    'neutral': '#ffffff'
                };
                
                this.focusHistory = [];
                this.lastFocusIntervention = 0;
                this.lowFocusCount = 0;
                this.FOCUS_THRESHOLD = 5;
                
                this.lastInterventionTime = 0;
                this.INTERVENTION_COOLDOWN = 30000;
                
                this.recentlyTriggeredEmotions = {};
                this.EMOTION_COOLDOWN = 30000;
                
                this.fullScreenIntervention = new FullScreenIntervention();
                
                this.startPeriodicLogging();
                this.startPeriodicCleanup();
                
                console.log('‚úÖ Intervention Monitor initialized with monitoring enabled');
            }

            startPeriodicLogging() {
                setInterval(() => {
                    this.logInterventionStatus();
                }, 5000);
            }
            
            startPeriodicCleanup() {
                setInterval(() => {
                    this.cleanupOldTriggers();
                }, 10000);
            }
            
            logInterventionStatus() {
                const now = Date.now();
                const timeSinceLastIntervention = now - this.lastInterventionTime;
                const emotionHistoryLength = this.state.emotionHistory ? this.state.emotionHistory.length : 0;
                const focusHistoryLength = this.focusHistory ? this.focusHistory.length : 0;
                
                console.log(`‚è≥ INTERVENTION MONITOR STATUS:`);
                console.log(`   - Last intervention time: ${new Date(this.lastInterventionTime).toLocaleTimeString()}`);
                console.log(`   - Time since last: ${Math.round(timeSinceLastIntervention/1000)}s`);
                console.log(`   - Cooldown needed: ${Math.round(this.INTERVENTION_COOLDOWN/1000)}s`);
                console.log(`   - Can trigger next? ${timeSinceLastIntervention > this.INTERVENTION_COOLDOWN ? '‚úÖ YES' : '‚è≥ NO'}`);
                console.log(`   - Remaining wait: ${Math.max(0, Math.round((this.INTERVENTION_COOLDOWN - timeSinceLastIntervention)/1000))}s`);
                console.log(`   - Emotion history: ${emotionHistoryLength} entries`);
                console.log(`   - Same emotion count: ${this.state.sameEmotionCount}/${this.state.EMOTION_TRIGGER_COUNT}`);
                console.log(`   - Focus low count: ${this.lowFocusCount}/${this.FOCUS_THRESHOLD}`);
                console.log(`   - Currently active emotions in cooldown: ${Object.keys(this.recentlyTriggeredEmotions).length}`);
                console.log(`   - Monitoring enabled: ${this.state.monitoringEnabled ? '‚úÖ YES' : '‚è≥ NO'}`);
                console.log('====================================');
            }

            monitorEmotion(emotion, confidence, timestamp) {
                // Check if monitoring is enabled
                if (!this.state.monitoringEnabled) {
                    console.log('‚è∏Ô∏è Emotion monitoring is temporarily paused');
                    return null;
                }
                
                // DEBUG: Log intervention status
                const interventionActive = this.fullScreenIntervention && this.fullScreenIntervention.isInterventionActive();
                console.log(`üîç DEBUG: Intervention active = ${interventionActive}, monitoring enabled = ${this.state.monitoringEnabled}`);
                
                // Always process emotions even if intervention is "supposedly" active
                // This fixes the stuck intervention issue
                if (interventionActive) {
                    console.log('‚ö†Ô∏è WARNING: Emotion detected during supposedly active intervention');
                    console.log('‚ö†Ô∏è Forcing intervention to inactive state');
                    
                    // Force intervention to inactive
                    this.fullScreenIntervention.isActive = false;
                    this.fullScreenIntervention.currentIntervention = null;
                    this.state.monitoringEnabled = true;
                }
                
                if (confidence < 0.6) {
                    console.log('üìä Low confidence emotion ignored:', emotion, Math.round(confidence*100)+'%');
                    return null;
                }
                            
                const mappedEmotion = this.mapEmotion(emotion.toLowerCase());
                
                console.log(`üé≠ Emotion detected: ${mappedEmotion} (${Math.round(confidence*100)}%)`);
                
                // Add to history
                if (!this.state.emotionHistory) {
                    this.state.emotionHistory = [];
                }
                
                this.state.emotionHistory.push({
                    emotion: mappedEmotion,
                    confidence: confidence,
                    timestamp: timestamp
                });
                
                // Keep only recent history (last 30 seconds)
                const recentCutoff = timestamp - 30000;
                this.state.emotionHistory = this.state.emotionHistory.filter(
                    e => e.timestamp > recentCutoff
                );
                
                // Check if same emotion continues
                if (mappedEmotion === this.state.currentDetectedEmotion) {
                    this.state.sameEmotionCount++;
                    console.log(`üî¢ Same emotion "${mappedEmotion}": ${this.state.sameEmotionCount}/${this.state.EMOTION_TRIGGER_COUNT}`);
                } else {
                    console.log(`üîÑ Emotion changed: ${this.state.currentDetectedEmotion} -> ${mappedEmotion}`);
                    this.state.currentDetectedEmotion = mappedEmotion;
                    this.state.sameEmotionCount = 1;
                }
                
                // Only trigger interventions for negative emotions
                const negativeEmotions = ['anger', 'disgust', 'fear', 'sad'];
                
                if (negativeEmotions.includes(mappedEmotion)) {
                    if (this.state.sameEmotionCount >= 3) {
                        console.log(`üé® Emotion frame changed to: ${mappedEmotion.toUpperCase()}`);
                        this.state.emotionFrameColor = this.getEmotionColor(mappedEmotion);
                        
                        const currentTime = Date.now();
                        const timeSinceLastIntervention = currentTime - this.lastInterventionTime;
                        
                        // Check if we can trigger an intervention
                        const canTrigger = this.canTriggerIntervention(mappedEmotion, currentTime);
                        
                        if (canTrigger) {
                            console.log(`üö® TRIGGERING INTERVENTION for: ${mappedEmotion}`);
                            
                            if (this.fullScreenIntervention && !this.fullScreenIntervention.isInterventionActive()) {
                                // Temporarily pause monitoring during intervention
                                this.state.monitoringEnabled = false;
                                
                                // Show intervention
                                this.fullScreenIntervention.show(mappedEmotion);
                                
                                // Update tracking
                                this.lastInterventionTime = currentTime;
                                this.recentlyTriggeredEmotions[mappedEmotion] = currentTime;
                                
                                // Reset tracking for this emotion
                                this.resetEmotionTrackingFor(mappedEmotion);
                                
                                this.updateEmotionFrameUI(mappedEmotion);
                                
                                // Schedule re-enablement of monitoring
                                setTimeout(() => {
                                    this.state.monitoringEnabled = true;
                                    console.log('‚úÖ Emotion monitoring re-enabled after intervention');
                                }, 1000);
                            }
                        } else {
                            console.log(`‚è≥ Cannot trigger intervention for ${mappedEmotion}: ${this.getInterventionBlockReason(mappedEmotion, currentTime)}`);
                        }
                    }
                }
                
                return mappedEmotion;
            }

            canTriggerIntervention(emotion, currentTime) {
                // Check cooldown
                const timeSinceLastIntervention = currentTime - this.lastInterventionTime;
                if (timeSinceLastIntervention < this.INTERVENTION_COOLDOWN) {
                    return false;
                }
                
                // Check if this emotion is in cooldown
                if (this.recentlyTriggeredEmotions[emotion]) {
                    const timeSinceLastTrigger = currentTime - this.recentlyTriggeredEmotions[emotion];
                    if (timeSinceLastTrigger < this.EMOTION_COOLDOWN) {
                        return false;
                    }
                }
                
                // Check if intervention is already active
                if (this.fullScreenIntervention && this.fullScreenIntervention.isInterventionActive()) {
                    return false;
                }
                
                return true;
            }

            getInterventionBlockReason(emotion, currentTime) {
                const timeSinceLastIntervention = currentTime - this.lastInterventionTime;
                
                if (timeSinceLastIntervention < this.INTERVENTION_COOLDOWN) {
                    return `Global cooldown: ${Math.round((this.INTERVENTION_COOLDOWN - timeSinceLastIntervention)/1000)}s left`;
                }
                
                if (this.recentlyTriggeredEmotions[emotion]) {
                    const timeSinceLastTrigger = currentTime - this.recentlyTriggeredEmotions[emotion];
                    if (timeSinceLastTrigger < this.EMOTION_COOLDOWN) {
                        return `Emotion cooldown: ${Math.round((this.EMOTION_COOLDOWN - timeSinceLastTrigger)/1000)}s left`;
                    }
                }
                
                if (this.fullScreenIntervention && this.fullScreenIntervention.isInterventionActive()) {
                    return 'Intervention already active';
                }
                
                return 'Unknown reason';
            }

            updateEmotionFrameUI(emotion) {
                const emotionInfoElement = document.getElementById('emotion-info');
                if (emotionInfoElement) {
                    const emotionColor = this.getEmotionColor(emotion);
                    emotionInfoElement.innerHTML = `
                        Emotion: <span style="color: ${emotionColor}; font-weight: bold;">
                            ${emotion.toUpperCase()}
                        </span><br>
                        Color: ${emotionColor}
                    `;
                }
                
                const dominantEmotionElement = document.getElementById('dominant-emotion');
                if (dominantEmotionElement) {
                    dominantEmotionElement.style.color = this.state.emotionFrameColor;
                }
            }

            mapEmotion(emotion) {
                const emotionMap = {
                    'angry': 'anger',
                    'disgust': 'disgust',
                    'fear': 'fear',
                    'happy': 'happy',
                    'sad': 'sad',
                    'surprise': 'surprise',
                    'contempt': 'contempt',
                    'neutral': 'neutral'
                };
                
                return emotionMap[emotion] || 'neutral';
            }

            monitorFocus(eyeScore, level, confidence, timestamp) {
                // Check if monitoring is enabled
                if (!this.state.monitoringEnabled) {
                    return;
                }
                
                // Check if intervention is active
                if (this.fullScreenIntervention && this.fullScreenIntervention.isInterventionActive()) {
                    return;
                }
                
                if (confidence < 0.3) return;
                
                if (!this.focusHistory) {
                    this.focusHistory = [];
                }
                
                this.focusHistory.push({
                    score: eyeScore,
                    level: level,
                    confidence: confidence,
                    timestamp: timestamp
                });
                
                const recentCutoff = timestamp - 15000;
                this.focusHistory = this.focusHistory.filter(
                    f => f.timestamp > recentCutoff
                );
                
                if (level === 'low' && eyeScore < 30) {
                    this.lowFocusCount++;
                    
                    console.log(`üëÅÔ∏è Low focus detected: score=${eyeScore}, level=${level} (count: ${this.lowFocusCount}/${this.FOCUS_THRESHOLD})`);
                    
                    if (this.lowFocusCount >= this.FOCUS_THRESHOLD &&
                        (timestamp - this.lastFocusIntervention) > 10000) {
                        
                        console.log(`üö® TRIGGERING INTERVENTION for distraction`);
                        
                        const currentTime = Date.now();
                        const timeSinceLastIntervention = currentTime - this.lastInterventionTime;
                        
                        if (timeSinceLastIntervention > this.INTERVENTION_COOLDOWN) {
                            this.recentlyTriggeredEmotions['distracted'] = currentTime;
                            
                            if (this.fullScreenIntervention && !this.fullScreenIntervention.isInterventionActive()) {
                                // Temporarily pause monitoring
                                this.state.monitoringEnabled = false;
                                
                                this.fullScreenIntervention.show('distracted');
                                this.lastInterventionTime = currentTime;
                                this.lastFocusIntervention = timestamp;
                                
                                this.resetFocusTracking();
                                
                                // Schedule re-enablement
                                setTimeout(() => {
                                    this.state.monitoringEnabled = true;
                                    console.log('‚úÖ Focus monitoring re-enabled after intervention');
                                }, 1000);
                            }
                        } else {
                            console.log(`‚è≥ Intervention on cooldown for distraction`);
                            console.log(`   - ${Math.round((this.INTERVENTION_COOLDOWN - timeSinceLastIntervention)/1000)}s remaining`);
                        }
                    }
                } else if (level === 'high' || level === 'medium') {
                    console.log(`üëÅÔ∏è‚úÖ Good focus detected: score=${eyeScore}, level=${level}, resetting low focus count`);
                    this.lowFocusCount = 0;
                }
            }

            getEmotionColor(emotion) {
                return this.emotionColors[emotion] || '#ffffff';
            }
            
            resetEmotionTrackingFor(emotion) {
                if (!this.state.emotionHistory) {
                    this.state.emotionHistory = [];
                }
                
                // Filter out this emotion from history
                this.state.emotionHistory = this.state.emotionHistory.filter(
                    e => e.emotion !== emotion
                );
                
                // Reset current detection if it matches
                if (this.state.currentDetectedEmotion === emotion) {
                    this.state.currentDetectedEmotion = 'neutral';
                    this.state.sameEmotionCount = 0;
                    this.state.emotionFrameColor = '#ffffff';
                }
                
                console.log(`üîÑ Reset tracking for emotion: ${emotion}`);
            }
            
            resetFocusTracking() {
                this.lowFocusCount = 0;
                this.focusHistory = [];
                console.log('üîÑ Reset focus tracking');
            }
            
            cleanupOldTriggers() {
                const currentTime = Date.now();
                for (const emotion in this.recentlyTriggeredEmotions) {
                    const triggerTime = this.recentlyTriggeredEmotions[emotion];
                    if (currentTime - triggerTime > this.EMOTION_COOLDOWN * 2) {
                        delete this.recentlyTriggeredEmotions[emotion];
                        console.log(`üßπ Cleaned up old trigger for: ${emotion}`);
                    }
                }
            }
            
            isBlockingGame() {
                return this.fullScreenIntervention ? this.fullScreenIntervention.isInterventionActive() : false;
            }
            
            getTimeSinceLastIntervention() {
                return Date.now() - this.lastInterventionTime;
            }
            
            getCooldownRemaining() {
                return Math.max(0, this.INTERVENTION_COOLDOWN - this.getTimeSinceLastIntervention());
            }
            
            resetTracking() {
                this.state = {
                    emotionHistory: [],
                    lastEmotionDetection: 0,
                    sameEmotionCount: 0,
                    currentDetectedEmotion: 'neutral',
                    emotionFrameColor: '#ffffff',
                    EMOTION_TRIGGER_COUNT: 3,
                    COOLDOWN: 1000,
                    monitoringEnabled: true
                };
                
                this.focusHistory = [];
                this.lastFocusIntervention = 0;
                this.lowFocusCount = 0;
                this.lastInterventionTime = 0;
                this.recentlyTriggeredEmotions = {};
                
                console.log('üîÑ Intervention tracking fully reset');
            }
            
            // Add a method to explicitly enable monitoring
            enableMonitoring() {
                this.state.monitoringEnabled = true;
                console.log('‚úÖ Emotion monitoring enabled');
            }
            
            // Add a method to explicitly disable monitoring
            disableMonitoring() {
                this.state.monitoringEnabled = false;
                console.log('‚è∏Ô∏è Emotion monitoring disabled');
            }
        }

        // ============================================
        // ENHANCED DUAL CAMERA DETECTION SYSTEM
        // ============================================

        class DualCameraDetection {
            constructor() {
                // Initialize video elements
                this.emotionVideo = document.getElementById('emotion-video');
                this.eyeVideo = document.getElementById('eye-video');
                
                if (!this.emotionVideo) {
                    console.error('Emotion video element not found!');
                    this.emotionVideo = document.createElement('video');
                    this.emotionVideo.id = 'emotion-video';
                    this.emotionVideo.className = 'detection-video';
                    this.emotionVideo.playsinline = true;
                    this.emotionVideo.muted = true;
                    document.body.appendChild(this.emotionVideo);
                }
                
                if (!this.eyeVideo) {
                    console.error('Eye video element not found!');
                    this.eyeVideo = document.createElement('video');
                    this.eyeVideo.id = 'eye-video';
                    this.eyeVideo.className = 'detection-video';
                    this.eyeVideo.playsinline = true;
                    this.eyeVideo.muted = true;
                    document.body.appendChild(this.eyeVideo);
                }
                
                // State management
                this.isEmotionRunning = false;
                this.isEyeTracking = false;
                this.emotionSecondCount = 0;
                this.emotionLastTimestamp = 0;
                this.emotionFPS = 0;
                this.lastInterventionTime = 0;
                this.INTERVENTION_COOLDOWN = 30000;

                // Initialize intervention monitor
                this.interventionMonitor = new InterventionMonitor();

                // Canvas elements
                this.emotionCanvas = document.getElementById('emotion-overlay');
                this.eyeCanvas = document.getElementById('eye-tracking-canvas');
                
                if (this.emotionCanvas) {
                    this.emotionCtx = this.emotionCanvas.getContext('2d');
                }
                
                if (this.eyeCanvas) {
                    this.eyeCtx = this.eyeCanvas.getContext('2d');
                }

                // Create separate video elements for processing only
                this.irisVideo = document.createElement('video');
                this.irisVideo.id = 'eye-processing-video';
                this.irisVideo.autoplay = true;
                this.irisVideo.playsinline = true;
                this.irisVideo.muted = true;
                this.irisVideo.style.display = 'none';
                document.body.appendChild(this.irisVideo);
                
                // Human.js instances
                this.emotionHuman = null;
                this.eyeHuman = null;
                
                // Eye tracking data
                this.irisData = {
                    left: { x: 0, y: 0, confidence: 0 },
                    right: { x: 0, y: 0, confidence: 0 },
                    center: { x: 0, y: 0, confidence: 0 },
                    confidence: 0
                };
                
                // Emotion tracking
                this.currentEmotion = 'neutral';
                this.emotionConfidence = 0;
                this.emotionHistory = [];
                this.EMOTION_HISTORY_MAX = 10;

                this.focusData = {
                    overallFocus: 'unknown',
                    focusScore: 0,
                    interventionCooldown: 15000,
                    lastFocusCheck: 0,
                    eyeDistanceFromCenter: 0,
                    cursorActivity: false,
                    lastCursorMove: 0,
                    cursorPosition: {x: 0, y: 0},
                    checkInterval: null
                };
                
                // Streams
                this.emotionStream = null;
                this.eyeStream = null;
                this.eyeScoreHistory = [];
                this.EYE_SCORE_HISTORY_MAX = 30;
                
                // Performance optimization properties
                this.DEBUG_MODE = false;
                this.lastIrisData = null;
                this.noFaceEyeCount = 0;
                this.eyeFrameCount = 0;
                this.emotionFrameCount = 0;
                this.lastEmotionDrawTime = 0;
                this.lastEmotionUpdate = 0;
                this.lastEyeUpdate = 0;
                
                // Initialize
                this.init();
            }
            
            async init() {
                try {
                    // Lighter emotion config
                    this.emotionHuman = new Human.default({
                        modelBasePath: 'https://cdn.jsdelivr.net/npm/@vladmandic/human/models/',
                        backend: 'webgl',
                        face: { 
                            enabled: true,
                            detector: { 
                                maxDetected: 1,
                                rotation: false,
                                return: true,
                                modelPath: 'blazeface-back.json',
                                skipFrames: 2
                            },
                            mesh: { 
                                enabled: false,
                            },
                            iris: { enabled: false },
                            emotion: { 
                                enabled: true,
                                modelPath: 'emotion.json'
                            },
                            description: { enabled: false },
                            liveness: { enabled: false },
                            antispoof: { enabled: false }
                        },
                        cacheSensitivity: 0.9,
                        skipFrames: 2,
                        deallocate: true
                    });
                    
                    // Even lighter eye config
                    this.eyeHuman = new Human.default({
                        modelBasePath: 'https://cdn.jsdelivr.net/npm/@vladmandic/human/models/',
                        backend: 'webgl',
                        face: { 
                            enabled: true,
                            detector: { 
                                maxDetected: 1,
                                rotation: false,
                                return: true,
                                modelPath: 'blazeface-back.json',
                                skipFrames: 3
                            },
                            mesh: { 
                                enabled: true,
                                modelPath: 'facemesh.json'
                            },
                            iris: { 
                                enabled: true,
                                maxDetected: 1,
                                minConfidence: 0.1
                            },
                            emotion: { enabled: false },
                            description: { enabled: false },
                            liveness: { enabled: false },
                            antispoof: { enabled: false }
                        },
                        cacheSensitivity: 0.9,
                        skipFrames: 3,
                        deallocate: true
                    });
                    
                    await Promise.all([
                        this.emotionHuman.load(),
                        this.eyeHuman.load()
                    ]);
                    
                    console.log('‚úÖ Dual camera detection models loaded');
                    
                    // Set up canvas sizes
                    this.resizeCanvases();
                    window.addEventListener('resize', () => this.resizeCanvases());
                    
                    // Initialize UI
                    this.initUI();
                    
                } catch (error) {
                    console.error('Failed to initialize dual camera detection:', error);
                    this.showError('Failed to load detection models. Please refresh the page.');
                }
            }

            resizeCanvases() {
                const getContainerSize = (selector) => {
                    const container = document.querySelector(selector);
                    if (!container) return { width: 300, height: 180 };
                    
                    const rect = container.getBoundingClientRect();
                    return {
                        width: Math.floor(rect.width),
                        height: Math.floor(rect.height)
                    };
                };
                
                const emotionSize = getContainerSize('.emotion-screen .video-container');
                const eyeSize = getContainerSize('.eye-screen .video-container');
                
                if (this.emotionCanvas) {
                    this.emotionCanvas.width = emotionSize.width;
                    this.emotionCanvas.height = emotionSize.height;
                }
                
                if (this.eyeCanvas) {
                    this.eyeCanvas.width = eyeSize.width;
                    this.eyeCanvas.height = eyeSize.height;
                }
            }
            
            initUI() {
                this.updateStatusIndicators();
                this.updateCameraBubbles();
            }

            updateCameraBubbles() {
                const emotionBubble = document.getElementById('side-emotion-camera');
                const eyeBubble = document.getElementById('side-eye-camera');
                const emotionDot = document.getElementById('emotion-status-dot');
                const eyeDot = document.getElementById('eye-status-dot');
                
                if (emotionBubble) {
                    if (this.isEmotionRunning) {
                        emotionBubble.classList.add('active');
                        if (emotionDot) {
                            emotionDot.className = 'camera-status-dot active';
                        }
                        emotionBubble.title = 'Emotion Detection (Active - Game)';
                    } else {
                        emotionBubble.classList.remove('active');
                        if (emotionDot) {
                            emotionDot.className = 'camera-status-dot inactive';
                        }
                        emotionBubble.title = 'Emotion Detection (Start Game to Activate)';
                    }
                }
                
                if (eyeBubble) {
                    if (this.isEyeTracking) {
                        eyeBubble.classList.add('active');
                        if (eyeDot) {
                            eyeDot.className = 'camera-status-dot active';
                        }
                        eyeBubble.title = 'Eye Tracking (Active - Game)';
                    } else {
                        eyeBubble.classList.remove('active');
                        if (eyeDot) {
                            eyeDot.className = 'camera-status-dot inactive';
                        }
                        eyeBubble.title = 'Eye Tracking (Start Game to Activate)';
                    }
                }
            }

            async autoStartBothDetectionsForGame() {
                console.log("üéÆ Starting BOTH detection systems for gameplay");
                
                try {
                    const irisInfo = document.getElementById('iris-info');
                    const focusStatus = document.getElementById('focus-status');
                    
                    if (irisInfo) irisInfo.textContent = 'Starting eye tracking...';
                    if (focusStatus) {
                        focusStatus.innerHTML = `
                            <div class="status-dot status-unknown"></div>
                            <span>Eye: Initializing...</span>
                        `;
                    }
                    
                    await this.startEmotionDetection();
                    await this.startEyeDetection();
                    
                    if (irisInfo) irisInfo.textContent = 'Eye tracking active. Looking for eyes...';
                    if (focusStatus) {
                        focusStatus.innerHTML = `
                            <div class="status-dot status-unknown"></div>
                            <span>Eye: Detecting...</span>
                        `;
                    }
                    
                    this.updateCameraBubbles();
                    
                    console.log("‚úÖ Both detection systems started for gameplay");
                    
                } catch (error) {
                    console.error("Failed to start detection systems:", error);
                }
            }
            
            async startEmotionDetection() {
                if (this.isEmotionRunning) return;
                
                try {
                    // Get camera with LOWER RESOLUTION
                    this.emotionStream = await navigator.mediaDevices.getUserMedia({
                        video: { 
                            width: { ideal: 320 },
                            height: { ideal: 240 },
                            frameRate: { ideal: 15 }
                        },
                        audio: false
                    });
                    
                    this.emotionVideo.srcObject = this.emotionStream;
                    
                    await new Promise(resolve => {
                        this.emotionVideo.onloadedmetadata = resolve;
                    });
                    
                    await this.emotionVideo.play();
                    
                    this.isEmotionRunning = true;
                    this.updateStatusIndicators();
                    this.updateCameraBubbles();
                    this.detectEmotionFrame();
                    
                } catch (error) {
                    console.error('Emotion camera error:', error);
                    throw error;
                }
            }
            
            async startEyeDetection() {
                if (this.isEyeTracking) return;
                
                try {
                    if (!this.eyeVideo) {
                        this.eyeVideo = document.getElementById('eye-video');
                        if (!this.eyeVideo) {
                            throw new Error('Eye video element not found');
                        }
                    }
                    
                    // Get camera with LOWER RESOLUTION
                    this.eyeStream = await navigator.mediaDevices.getUserMedia({
                        video: { 
                            width: { ideal: 320 },
                            height: { ideal: 240 },
                            facingMode: 'user',
                            frameRate: { ideal: 15 }
                        },
                        audio: false
                    });
                    
                    this.eyeVideo.srcObject = this.eyeStream;
                    
                    await new Promise((resolve) => {
                        const checkReady = () => {
                            if (this.eyeVideo.readyState >= 2) {
                                resolve();
                            } else {
                                this.eyeVideo.onloadeddata = resolve;
                            }
                        };
                        checkReady();
                    });
                    
                    await this.eyeVideo.play();
                    
                    this.isEyeTracking = true;
                    this.updateStatusIndicators();
                    this.updateCameraBubbles();
                    
                    this.detectEyeFrame();
                    
                    console.log('‚úÖ Eye tracking started');
                    
                } catch (error) {
                    console.error('Eye camera error:', error);
                    throw error;
                }
            }

            calculateEyeScore() {
                if (this.irisData.confidence < 0.3) {
                    return { 
                        score: 0, 
                        level: 'unknown',
                        distance: 1.0,
                        direction: 'unknown'
                    };
                }
                
                const irisCenter = this.irisData.center;
                const distanceX = irisCenter.x - 0.5;
                const distanceY = irisCenter.y - 0.5;
                const rawDistance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
                const normalizedDistance = Math.min(1, rawDistance / 0.707);
                const eyeScore = Math.round(100 * (1 - normalizedDistance));
                const confidenceAdjustedScore = Math.round(eyeScore * this.irisData.confidence);
                
                let direction = 'CENTER';
                if (Math.abs(distanceX) > 0.1 || Math.abs(distanceY) > 0.1) {
                    if (Math.abs(distanceX) > Math.abs(distanceY)) {
                        direction = distanceX > 0 ? 'RIGHT' : 'LEFT';
                    } else {
                        direction = distanceY > 0 ? 'DOWN' : 'UP';
                    }
                }
                
                let level = 'low';
                if (confidenceAdjustedScore >= 80) level = 'high';
                else if (confidenceAdjustedScore >= 50) level = 'medium';
                
                return {
                    score: confidenceAdjustedScore,
                    level: level,
                    distance: rawDistance,
                    normalizedDistance: normalizedDistance,
                    direction: direction,
                    confidence: this.irisData.confidence,
                    rawEyeScore: eyeScore
                };
            }

            updateGameActiveUI() {
                const emotionStatus = document.getElementById('emotion-status');
                const eyeStatus = document.getElementById('eye-status');
                
                if (emotionStatus) {
                    emotionStatus.innerHTML = '<i class="fas fa-circle" style="color: #95e1d3;"></i> ACTIVE (Game)';
                    emotionStatus.className = 'screen-status active';
                }
                
                if (eyeStatus) {
                    eyeStatus.innerHTML = '<i class="fas fa-circle" style="color: #95e1d3;"></i> ACTIVE (Game)';
                    eyeStatus.className = 'screen-status active';
                }
                
                this.updateCameraBubbles();
            }
            
            autoStopBothDetectionsAfterGame() {
                console.log("üõë Stopping BOTH detection systems after game");
                
                if (this.isEmotionRunning) {
                    this.stopEmotionDetection();
                }
                
                if (this.isEyeTracking) {
                    this.stopEyeDetection();
                }
                
                this.showInfo("Game monitoring stopped.");
                this.updateInactiveUI();
                
                console.log("‚úÖ Both detection systems stopped after game");
            }
            
            updateEmotionDisplayThrottled(emotion, confidence) {
                this.lastEmotionUpdate = this.lastEmotionUpdate || 0;
                const now = Date.now();
                
                if (now - this.lastEmotionUpdate > 500) {
                    const confidencePercent = Math.round(confidence * 100);
                    const emotionColor = this.interventionMonitor.getEmotionColor(emotion);
                    
                    const dominantEmotionElement = document.getElementById('dominant-emotion');
                    const emotionConfidenceElement = document.getElementById('emotion-confidence');
                    
                    if (dominantEmotionElement) {
                        dominantEmotionElement.textContent = emotion;
                        dominantEmotionElement.style.color = emotionColor;
                    }
                    
                    if (emotionConfidenceElement) {
                        emotionConfidenceElement.textContent = `${confidencePercent}%`;
                    }
                    
                    this.lastEmotionUpdate = now;
                }
            }

            updateInactiveUI() {
                const emotionStatus = document.getElementById('emotion-status');
                const eyeStatus = document.getElementById('eye-status');
                
                if (emotionStatus) {
                    emotionStatus.innerHTML = '<i class="fas fa-circle" style="color: #ff6b8b;"></i> INACTIVE (Start Game)';
                    emotionStatus.className = 'screen-status';
                }
                
                if (eyeStatus) {
                    eyeStatus.innerHTML = '<i class="fas fa-circle" style="color: #ff6b8b;"></i> INACTIVE (Start Game)';
                    eyeStatus.className = 'screen-status';
                }
                
                this.updateCameraBubbles();
            }
            
            stopEmotionDetection() {
                if (this.emotionStream) {
                    this.emotionStream.getTracks().forEach(track => track.stop());
                    this.emotionStream = null;
                }
                
                if (this.emotionVideo) {
                    this.emotionVideo.srcObject = null;
                }
                
                this.isEmotionRunning = false;
                
                if (this.emotionCtx) {
                    this.emotionCtx.clearRect(0, 0, this.emotionCanvas.width, this.emotionCanvas.height);
                }
                
                document.getElementById('face-count').textContent = '0';
                document.getElementById('dominant-emotion').textContent = '-';
                document.getElementById('emotion-confidence').textContent = '0%';
                document.getElementById('emotion-info').textContent = 'Emotion: Waiting for game to start';
                
                this.updateCameraBubbles();
                
                console.log('üõë Emotion detection stopped');
            }
            
            stopEyeDetection() {
                if (this.eyeStream) {
                    this.eyeStream.getTracks().forEach(track => track.stop());
                    this.eyeStream = null;
                }
                
                if (this.eyeVideo) {
                    this.eyeVideo.srcObject = null;
                }
                
                this.isEyeTracking = false;
                
                if (this.eyeCtx) {
                    this.eyeCtx.clearRect(0, 0, this.eyeCanvas.width, this.eyeCanvas.height);
                }
                
                const irisConfidenceElement = document.getElementById('eye-iris-confidence');
                const focusDirectionElement = document.getElementById('focus-direction');
                
                if (irisConfidenceElement) irisConfidenceElement.textContent = '0%';
                if (focusDirectionElement) focusDirectionElement.textContent = '-';
                
                this.updateCameraBubbles();
                
                console.log('üõë Eye tracking stopped');
            }
            
            updateStatusIndicators() {
                const emotionStatus = document.getElementById('emotion-status');
                const eyeStatus = document.getElementById('eye-status');
                
                if (emotionStatus) {
                    emotionStatus.innerHTML = this.isEmotionRunning ? 
                        '<i class="fas fa-circle" style="color: #95e1d3;"></i> ACTIVE (Game)' : 
                        '<i class="fas fa-circle" style="color: #ff6b8b;"></i> INACTIVE (Start Game)';
                    emotionStatus.className = this.isEmotionRunning ? 
                        'screen-status active' : 'screen-status';
                }
                
                if (eyeStatus) {
                    eyeStatus.innerHTML = this.isEyeTracking ? 
                        '<i class="fas fa-circle" style="color: #95e1d3;"></i> ACTIVE (Game)' : 
                        '<i class="fas fa-circle" style="color: #ff6b8b;"></i> INACTIVE (Start Game)';
                    eyeStatus.className = this.isEyeTracking ? 
                        'screen-status active' : 'screen-status';
                }
            }

            stopBothDetections() {
                this.stopEmotionDetection();
                this.stopEyeDetection();
            }
            
            // Optimized emotion detection with frame skipping
            async detectEmotionFrame() {
                if (!this.isEmotionRunning) return;
                
                // FRAME SKIPPING: Process only every 2nd frame (30 FPS instead of 60)
                this.emotionFrameCount = this.emotionFrameCount || 0;
                this.emotionFrameCount++;
                
                if (this.emotionFrameCount % 2 !== 0) {
                    requestAnimationFrame(() => this.detectEmotionFrame());
                    return;
                }
                
                try {
                    // Update FPS counter less frequently
                    this.updateEmotionFPS();
                    
                    // Run detection with optimization
                    const result = await this.emotionHuman.detect(this.emotionVideo, {
                        skipFrames: 1,
                        cacheSensitivity: 0.9
                    });
                    
                    this.lastEmotionDrawTime = this.lastEmotionDrawTime || 0;
                    const now = Date.now();
                    
                // In detectEmotionFrame method:
                if (result.face && result.face.length > 0) {
                    const face = result.face[0];
                    const dominantEmotion = this.getDominantEmotion(face);
                    const mappedEmotion = this.interventionMonitor.mapEmotion(dominantEmotion.name);
                    
                    // Draw face detection
                    this.drawEmotionFaceDetection(face, mappedEmotion, dominantEmotion.confidence);
                    
                    // Update displays (throttled)
                    this.updateEmotionDisplayThrottled(mappedEmotion, dominantEmotion.confidence);
                    
                    // Check for interventions - ALWAYS call monitorEmotion
                    const monitoredEmotion = this.interventionMonitor.monitorEmotion(
                        dominantEmotion.name,
                        dominantEmotion.confidence,
                        Date.now()
                    );
                    
                    // Update face count
                    const faceCountElement = document.getElementById('face-count');
                    if (faceCountElement) {
                        faceCountElement.textContent = result.face.length;
                    }
                    
                    this.lastEmotionDrawTime = now;
                }
                                    
                } catch (error) {
                    console.log('Detection error:', error);
                }
                
                // Continue with throttled loop
                setTimeout(() => {
                    requestAnimationFrame(() => this.detectEmotionFrame());
                }, 33); // Target ~30 FPS
            }
            
            // Optimized eye detection with frame skipping
            async detectEyeFrame() {
                if (!this.isEyeTracking || !this.eyeHuman || !this.eyeVideo) {
                    return;
                }
                
                // FRAME SKIPPING for eye tracking
                this.eyeFrameCount = this.eyeFrameCount || 0;
                this.eyeFrameCount++;
                
                if (this.eyeFrameCount % 3 !== 0) { // Process every 3rd frame (~20 FPS)
                    requestAnimationFrame(() => this.detectEyeFrame());
                    return;
                }
                
                try {
                    if (this.eyeVideo.readyState >= 2) {
                        // Use optimized detection settings
                        const result = await this.eyeHuman.detect(this.eyeVideo, {
                            skipFrames: 2,
                            cacheSensitivity: 0.9,
                            face: {
                                iris: {
                                    enabled: true,
                                    maxDetected: 1
                                }
                            }
                        });
                        
                        if (result.face && result.face.length > 0) {
                            const face = result.face[0];
                            const irisData = this.extractIrisData(face);
                            
                            // Update display only if data changed significantly
                            if (this.shouldUpdateEyeDisplay(irisData)) {
                                this.updateEyeInfoDisplay(irisData);
                                this.updateIrisData(irisData.left, irisData.right, irisData.confidence);
                            }
                            
                            // Check focus
                            const eyeScoreData = this.calculateEyeScore();
                            if (this.interventionMonitor && !this.interventionMonitor.isBlockingGame()) {
                                this.interventionMonitor.monitorFocus(
                                    eyeScoreData.score,
                                    eyeScoreData.level,
                                    eyeScoreData.confidence,
                                    Date.now()
                                );
                            }
                            
                        } else {
                            // Update less frequently when no face
                            this.noFaceEyeCount = this.noFaceEyeCount || 0;
                            if (this.noFaceEyeCount++ % 10 === 0) {
                                this.updateEyeInfoDisplay({confidence: 0});
                                this.updateIrisData([0.5, 0.5], [0.5, 0.5], 0);
                            }
                        }
                    }
                } catch (error) {
                    console.error('Eye detection error:', error);
                }
                
                // Throttled loop continuation
                setTimeout(() => {
                    requestAnimationFrame(() => this.detectEyeFrame());
                }, 50); // Target ~20 FPS
            }
            
            // Helper method to check if eye display should update
            shouldUpdateEyeDisplay(newIrisData) {
                if (!this.lastIrisData) {
                    this.lastIrisData = newIrisData;
                    return true;
                }
                
                const confidenceChanged = Math.abs(newIrisData.confidence - this.lastIrisData.confidence) > 0.1;
                const positionChanged = newIrisData.left && this.lastIrisData.left ?
                    Math.abs(newIrisData.left[0] - this.lastIrisData.left[0]) > 0.05 ||
                    Math.abs(newIrisData.left[1] - this.lastIrisData.left[1]) > 0.05 : false;
                
                if (confidenceChanged || positionChanged) {
                    this.lastIrisData = newIrisData;
                    return true;
                }
                
                return false;
            }
            
            // Clear emotion canvas
            clearEmotionCanvas() {
                if (this.emotionCtx) {
                    this.emotionCtx.clearRect(0, 0, this.emotionCanvas.width, this.emotionCanvas.height);
                }
            }
            
            // Update display when no face detected
            updateNoFaceDisplay() {
                const faceCountElement = document.getElementById('face-count');
                const dominantEmotionElement = document.getElementById('dominant-emotion');
                const emotionConfidenceElement = document.getElementById('emotion-confidence');
                const emotionInfoElement = document.getElementById('emotion-info');
                
                if (faceCountElement) faceCountElement.textContent = '0';
                if (dominantEmotionElement) {
                    dominantEmotionElement.textContent = '-';
                    dominantEmotionElement.style.color = '';
                }
                if (emotionConfidenceElement) emotionConfidenceElement.textContent = '0%';
                if (emotionInfoElement) emotionInfoElement.textContent = 'Emotion: No face detected';
            }
            
            drawEmotionFaceDetection(face, mappedEmotion, confidence) {
                const ctx = this.emotionCtx;
                const canvasWidth = this.emotionCanvas.width;
                const canvasHeight = this.emotionCanvas.height;
                const videoWidth = this.emotionVideo.videoWidth;
                const videoHeight = this.emotionVideo.videoHeight;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                
                // Draw video frame
                ctx.drawImage(this.emotionVideo, 0, 0, canvasWidth, canvasHeight);
                
                if (!face.box) return;
                
                const scaleX = canvasWidth / videoWidth;
                const scaleY = canvasHeight / videoHeight;
                const [x, y, width, height] = face.box;
                
                const scaledX = x * scaleX;
                const scaledY = y * scaleY;
                const scaledWidth = width * scaleX;
                const scaledHeight = height * scaleY;
                
                const emotionColor = this.interventionMonitor.getEmotionColor(mappedEmotion);
                
                // Draw face box
                ctx.strokeStyle = emotionColor;
                ctx.lineWidth = 2;
                ctx.strokeRect(scaledX, scaledY, scaledWidth, scaledHeight);
                
                // Draw emotion label
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(scaledX + scaledWidth - 120, scaledY - 20, 115, 18);
                
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(
                    `${mappedEmotion} ${Math.round(confidence * 100)}%`,
                    scaledX + scaledWidth - 5,
                    scaledY - 5
                );
                ctx.textAlign = 'left';
            }

            getDominantEmotion(face) {
                if (!face.emotion || !Array.isArray(face.emotion) || face.emotion.length === 0) {
                    return { name: 'neutral', confidence: 0.5 };
                }
                
                const topEmotion = face.emotion[0];
                return {
                    name: topEmotion.emotion || 'neutral',
                    confidence: topEmotion.score || 0.5
                };
            }

            updateEmotionFPS() {
                const now = performance.now();
                this.emotionSecondCount++;
                
                if (now >= this.emotionLastTimestamp + 1000) {
                    this.emotionFPS = this.emotionSecondCount;
                    this.emotionLastTimestamp = now;
                    this.emotionSecondCount = 0;
                    
                    const fpsElement = document.getElementById('emotion-fps');
                    if (fpsElement) {
                        fpsElement.textContent = this.emotionFPS;
                    }
                }
            }

            updateEyeInfoDisplay(irisData) {
                const irisInfoElement = document.getElementById('iris-info');
                const focusStatusElement = document.getElementById('focus-status');
                
                if (!irisInfoElement || !focusStatusElement) return;
                
                if (irisData.confidence > 0.3) {
                    const confidence = Math.round(irisData.confidence * 100);
                    const eyeScore = this.calculateEyeScore();
                    
                    irisInfoElement.innerHTML = `
                        Eye Score: <strong style="color: ${eyeScore.level === 'high' ? '#4CAF50' : 
                                                        eyeScore.level === 'medium' ? '#FFA500' : '#F44336'}">
                            ${eyeScore.score}%
                        </strong> | 
                        Confidence: ${confidence}%<br>
                        Looking: ${eyeScore.direction}
                    `;
                    
                    let statusClass = 'status-unknown';
                    let statusText = `Eye: ${eyeScore.score}%`;
                    
                    switch(eyeScore.level) {
                        case 'high':
                            statusClass = 'status-focusing';
                            statusText = `Eye: FOCUSED ${eyeScore.score}% ‚úÖ`;
                            break;
                        case 'medium':
                            statusClass = 'status-unknown';
                            statusText = `Eye: OKAY ${eyeScore.score}% ü§î`;
                            break;
                        case 'low':
                            statusClass = 'status-distracted';
                            statusText = `Eye: LOW ${eyeScore.score}% ‚ùå`;
                            break;
                    }
                    
                    focusStatusElement.innerHTML = `
                        <div class="status-dot ${statusClass}"></div>
                        <span>${statusText}</span>
                    `;
                    
                } else {
                    irisInfoElement.textContent = 'Looking for eyes...';
                    focusStatusElement.innerHTML = `
                        <div class="status-dot status-unknown"></div>
                        <span>Eye: Searching...</span>
                    `;
                }
            }

            extractIrisData(face) {
                let leftIris = [0.5, 0.5];
                let rightIris = [0.5, 0.5];
                let confidence = 0.1;
                
                const videoWidth = this.eyeVideo.videoWidth || 320;
                const videoHeight = this.eyeVideo.videoHeight || 240;
                
                if (face.annotations && face.annotations.rightEyeIris && face.annotations.leftEyeIris) {
                    const leftPoints = face.annotations.leftEyeIris;
                    const rightPoints = face.annotations.rightEyeIris;
                    
                    if (leftPoints.length >= 5) {
                        const avgX = leftPoints.reduce((sum, p) => sum + p[0], 0) / leftPoints.length;
                        const avgY = leftPoints.reduce((sum, p) => sum + p[1], 0) / leftPoints.length;
                        
                        leftIris = [
                            avgX / videoWidth,
                            avgY / videoHeight
                        ];
                    }
                    
                    if (rightPoints.length >= 5) {
                        const avgX = rightPoints.reduce((sum, p) => sum + p[0], 0) / rightPoints.length;
                        const avgY = rightPoints.reduce((sum, p) => sum + p[1], 0) / rightPoints.length;
                        
                        rightIris = [
                            avgX / videoWidth,
                            avgY / videoHeight
                        ];
                    }
                    
                    confidence = face.score || 0.7;
                }
                
                return { 
                    left: leftIris, 
                    right: rightIris, 
                    confidence: Math.min(1, Math.max(0.1, confidence))
                };
            }

            updateIrisData(leftIris, rightIris, confidence) {
                const left = Array.isArray(leftIris) ? leftIris : [0.5, 0.5];
                const right = Array.isArray(rightIris) ? rightIris : [0.5, 0.5];
                
                this.irisData.left = { 
                    x: left[0], 
                    y: left[1], 
                    confidence: confidence 
                };
                
                this.irisData.right = { 
                    x: right[0], 
                    y: right[1], 
                    confidence: confidence 
                };
                
                this.irisData.center = {
                    x: (left[0] + right[0]) / 2,
                    y: (left[1] + right[1]) / 2,
                    confidence: confidence
                };
                
                this.irisData.confidence = confidence;
                
                this.updateIrisDisplay();
                this.calculateFocusMetrics();
            }

            updateIrisDisplay() {
                const confidence = Math.round(this.irisData.confidence * 100);
                const eyeScoreData = this.calculateEyeScore();
                
                const irisConfidenceElement = document.getElementById('eye-iris-confidence');
                if (irisConfidenceElement) {
                    irisConfidenceElement.textContent = `${confidence}%`;
                    irisConfidenceElement.style.color = confidence > 70 ? '#4CAF50' : 
                                                       confidence > 40 ? '#FFA500' : '#F44336';
                }
                
                const eyeScoreElement = document.getElementById('eye-score');
                if (eyeScoreElement) {
                    eyeScoreElement.textContent = `${eyeScoreData.score}%`;
                    eyeScoreElement.style.color = eyeScoreData.level === 'high' ? '#4CAF50' : 
                                                  eyeScoreData.level === 'medium' ? '#FFA500' : '#F44336';
                }
                
                const alignmentScoreElement = document.getElementById('eye-alignment-score');
                if (alignmentScoreElement) {
                    const alignment = Math.round(100 - eyeScoreData.normalizedDistance * 100);
                    alignmentScoreElement.textContent = `${alignment}%`;
                    alignmentScoreElement.style.color = alignment > 80 ? '#4CAF50' : 
                                                        alignment > 60 ? '#FFA500' : '#F44336';
                }
                
                const focusDirectionElement = document.getElementById('focus-direction');
                if (focusDirectionElement) {
                    focusDirectionElement.textContent = eyeScoreData.direction;
                    focusDirectionElement.style.color = eyeScoreData.direction === 'CENTER' ? '#4CAF50' : '#F44336';
                }
            }

            calculateFocusMetrics() {
                if (this.irisData.confidence < 0.3) {
                    this.updateEyeScoreDisplay(0, 'unknown');
                    
                    const eyeScoreElement = document.getElementById('eye-score');
                    const alignmentScoreElement = document.getElementById('eye-alignment-score');
                    const focusDirectionElement = document.getElementById('focus-direction');
                    
                    if (eyeScoreElement) eyeScoreElement.textContent = '0%';
                    if (alignmentScoreElement) alignmentScoreElement.textContent = '0%';
                    if (focusDirectionElement) focusDirectionElement.textContent = '-';
                    
                    return;
                }
                
                const eyeScoreData = this.calculateEyeScore();
                
                const eyeScoreElement = document.getElementById('eye-score');
                const alignmentScoreElement = document.getElementById('eye-alignment-score');
                const focusDirectionElement = document.getElementById('focus-direction');
                
                if (eyeScoreElement) eyeScoreElement.textContent = `${eyeScoreData.score}%`;
                if (alignmentScoreElement) alignmentScoreElement.textContent = `${Math.round(100 - eyeScoreData.normalizedDistance * 100)}%`;
                if (focusDirectionElement) focusDirectionElement.textContent = eyeScoreData.direction;
                
                this.updateEyeScoreDisplay(eyeScoreData.score, eyeScoreData.level);
            }

            updateEyeScoreDisplay(score, level = 'unknown') {
                const focusStatus = document.getElementById('focus-status');
                if (!focusStatus) return;
                
                let statusClass = 'status-unknown';
                let statusText = 'Eye Score: -';
                let emoji = 'üëÅÔ∏è';
                
                switch(level) {
                    case 'high':
                        statusClass = 'status-focusing';
                        statusText = `Eye Score: ${score}% üëç`;
                        emoji = 'üëÅÔ∏è‚úÖ';
                        break;
                    case 'medium':
                        statusClass = 'status-unknown';
                        statusText = `Eye Score: ${score}% ü§î`;
                        emoji = 'üëÅÔ∏è‚ö†Ô∏è';
                        break;
                    case 'low':
                        statusClass = 'status-distracted';
                        statusText = `Eye Score: ${score}% ‚ùå`;
                        emoji = 'üëÅÔ∏è‚ùå';
                        break;
                    default:
                        emoji = 'üëÅÔ∏è‚ùì';
                }
                
                focusStatus.innerHTML = `
                    <div class="status-dot ${statusClass}"></div>
                    <span>${emoji} ${statusText}</span>
                `;
            }

            showSuccess(message) {
                this.updateStatusPanel('success', message);
            }
            
            showError(message) {
                this.updateStatusPanel('error', message);
            }
            
            showInfo(message) {
                this.updateStatusPanel('info', message);
            }
            
            updateStatusPanel(type, message) {
                const statusPanel = document.getElementById('detection-status');
                if (!statusPanel) return;
                
                let icon = 'fa-magic';
                let title = 'ENHANCED EMOTION & EYE TRACKING';
                let color = '#25221a';
                
                switch(type) {
                    case 'success':
                        icon = 'fa-check-circle';
                        color = '#95e1d3';
                        break;
                    case 'error':
                        icon = 'fa-exclamation-circle';
                        color = '#d84a54';
                        break;
                    case 'info':
                        icon = 'fa-info-circle';
                        color = '#8ac6d1';
                        break;
                }
                
                statusPanel.innerHTML = `
                    <div class="status-header">
                        <div class="status-icon" style="color: ${color};">
                            <i class="fas ${icon}"></i>
                        </div>
                        <div class="status-title">
                            ${title}
                        </div>
                    </div>
                    <div class="status-message">
                        ${message}
                    </div>
                `;
            }
        }

        // ============================================
        // INITIALIZATION
        // ============================================

        let dualCameraDetection = null;

        window.addEventListener('load', function() {
            initSideToggle();
            
            if (typeof Human !== 'undefined') {
                dualCameraDetection = new DualCameraDetection();
            } else {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/@vladmandic/human/dist/human.js';
                script.onload = function() {
                    dualCameraDetection = new DualCameraDetection();
                    console.log('‚úÖ Dual camera detection initialized with Human.js');
                };
                document.head.appendChild(script);
            }
            
            // Add Font Awesome
            const faLink = document.createElement('link');
            faLink.rel = 'stylesheet';
            faLink.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css';
            document.head.appendChild(faLink);
            
            // Add fonts
            const fontLink = document.createElement('link');
            fontLink.href = 'https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&family=Fredoka+One&display=swap';
            fontLink.rel = 'stylesheet';
            document.head.appendChild(fontLink);
            
            // Listen for messages from parent
window.addEventListener('message', function(event) {
    if (event.data.type === 'start-game-detection') {
        if (dualCameraDetection) {
            dualCameraDetection.autoStartBothDetectionsForGame();
        }
    } else if (event.data.type === 'stop-game-detection') {
        if (dualCameraDetection) {
            dualCameraDetection.autoStopBothDetectionsAfterGame();
        }
    } else if (event.data.type === 'open-camera-panel') {
        openCameraPanel();
    } else if (event.data.type === 'close-camera-panel') {
        closeCameraPanel();
    } else if (event.data.type === 'initialize-camera') {
        console.log('Initializing camera detection system');
    } else if (event.data.type === 'INTERVENTION_ACKNOWLEDGED') {  // NEW
        console.log('‚úÖ Parent acknowledged intervention completion');
        
        // Make SURE intervention is marked as inactive
        if (window.interventionMonitor && window.interventionMonitor.fullScreenIntervention) {
            window.interventionMonitor.fullScreenIntervention.isActive = false;
            window.interventionMonitor.fullScreenIntervention.currentIntervention = null;
            window.interventionMonitor.enableMonitoring();
            console.log('‚úÖ Forced intervention state to inactive');
        }
    }

    if (event.data.type === 'RESET_EMOTION_TRACKING') {
        if (dualCameraDetection && dualCameraDetection.interventionMonitor) {
            dualCameraDetection.interventionMonitor.state.emotionHistory = [];
            dualCameraDetection.interventionMonitor.state.sameEmotionCount = 0;
            dualCameraDetection.interventionMonitor.state.currentDetectedEmotion = 'neutral';
            
            console.log('üîÑ Emotion tracking reset after intervention');
        }
    }
});

            // Notify parent that iframe is loaded
            if (window.parent !== window) {
                window.parent.postMessage({ type: 'iframe-loaded' }, '*');
            }
            
            // Close speaking bot overlay when clicking outside container
            const speakingBotOverlay = document.getElementById('speaking-bot-overlay-main');
            if (speakingBotOverlay) {
                speakingBotOverlay.addEventListener('click', function(e) {
                    if (e.target === this) {
                        hideSpeakingBotOverlay();
                    }
                });
            }
        });

        // Export functions
        window.dualCameraDetection = dualCameraDetection;
        window.openCameraPanel = openCameraPanel;
        window.closeCameraPanel = closeCameraPanel;
        window.showSpeakingBotOverlay = showSpeakingBotOverlay;
        window.hideSpeakingBotOverlay = hideSpeakingBotOverlay;
    </script>
</body>
</html>